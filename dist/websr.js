/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["WebSR"] = factory();
	else
		root["WebSR"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/context.ts":
/*!************************!*\
  !*** ./src/context.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass WebGPUContext {\n    constructor(device, resolution, canvas, debug) {\n        this.device = device;\n        this.canvas = canvas;\n        this.resolution = resolution;\n        this.textures = {};\n        this.buffers = {};\n        this.destroyed = false;\n        this.debug = debug;\n        let context = this.canvas.getContext('webgpu');\n        if (context instanceof GPUCanvasContext) {\n            this.context = context;\n        }\n        else {\n            throw new Error(\"Unable to load WebGPU context\");\n        }\n        this.context.configure({\n            device: this.device,\n            format: navigator.gpu.getPreferredCanvasFormat()\n        });\n        this.textureUsage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT;\n        this.bufferUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n        if (this.debug) {\n            // Read output pixel value\n            this.textureUsage = this.textureUsage | GPUTextureUsage.COPY_SRC;\n            this.bufferUsage = this.bufferUsage | GPUBufferUsage.COPY_SRC;\n        }\n        this.textures['output'] = this.context.getCurrentTexture();\n    }\n    readBuffer(bufferName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.buffers[bufferName])\n                throw new Error(`No buffer with name ${bufferName}`);\n            const readEncoder = this.device.createCommandEncoder({\n                label: `Read ${bufferName} buffer encoder`,\n            });\n            const buffer = this.buffers[bufferName];\n            const resultBuffer = this.device.createBuffer({\n                label: 'result buffer',\n                size: buffer.size,\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n            });\n            readEncoder.copyBufferToBuffer(buffer, 0, resultBuffer, 0, resultBuffer.size);\n            this.device.queue.submit([readEncoder.finish()]);\n            yield resultBuffer.mapAsync(GPUMapMode.READ);\n            let range = resultBuffer.getMappedRange();\n            return new Float32Array(range);\n        });\n    }\n    readTexture(textureName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.textures[textureName])\n                throw new Error(`No texture with name ${textureName}`);\n            const readEncoder = this.device.createCommandEncoder({\n                label: `Read ${textureName} texture encoder`,\n            });\n            const texture = this.textures[textureName];\n            let bitsPerPixel = 16;\n            if (texture.format === 'rgba8unorm')\n                bitsPerPixel = 4;\n            if (texture.format === 'r32float')\n                bitsPerPixel = 4;\n            const resultBuffer = this.device.createBuffer({\n                label: 'result buffer',\n                size: texture.width * texture.height * bitsPerPixel,\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n            });\n            readEncoder.copyTextureToBuffer({\n                texture: this.textures[textureName],\n            }, {\n                buffer: resultBuffer,\n                bytesPerRow: texture.width * bitsPerPixel\n            }, {\n                width: texture.width,\n                height: texture.height,\n                depthOrArrayLayers: 1,\n            });\n            this.device.queue.submit([readEncoder.finish()]);\n            yield resultBuffer.mapAsync(GPUMapMode.READ);\n            if (texture.format === 'r32float')\n                return new Float32Array(resultBuffer.getMappedRange());\n            else if (texture.format === 'rgba32float')\n                return new Float32Array(resultBuffer.getMappedRange());\n            else if (texture.format === 'rgba8unorm')\n                return new Uint8ClampedArray(resultBuffer.getMappedRange());\n            return new Float32Array(0);\n        });\n    }\n    destroy() {\n        this.device.destroy();\n        this.destroyed = true;\n    }\n    buffer(key, options) {\n        if (!this.buffers[key]) {\n            options = options || {};\n            const width = options.width || this.resolution.width;\n            const height = options.height || this.resolution.height;\n            const channels = options.channels || 4;\n            const bitdepth = options.bitdepth || 4;\n            this.buffers[key] = this.device.createBuffer({\n                label: key,\n                size: width * height * channels * bitdepth,\n                usage: this.bufferUsage\n            });\n        }\n        return this.buffers[key];\n    }\n    texture(key, options) {\n        if (!this.textures[key]) {\n            options = options || {};\n            this.textures[key] = this.device.createTexture({\n                label: key,\n                size: [options.width || this.resolution.width, options.height || this.resolution.height],\n                format: options.format || 'rgba32float',\n                usage: this.textureUsage\n            });\n        }\n        return this.textures[key];\n    }\n}\nexports[\"default\"] = WebGPUContext;\n\n\n//# sourceURL=webpack://WebSR/./src/context.ts?");

/***/ }),

/***/ "./src/layers/anime4k/conv2d-3x4.ts":
/*!******************************************!*\
  !*** ./src/layers/anime4k/conv2d-3x4.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \"./src/layers/base_compute_layer.ts\");\nclass Anime4KConv3x4 extends base_compute_layer_1.default {\n    constructor(inputTextures, outputBuffer, weights) {\n        super(inputTextures, outputBuffer, weights);\n        this.label = \"Anime4KConv3x4\";\n        const kernels = weights.weights;\n        const bias = weights.bias;\n        this.createUniform(\"kernel_offsets\", \"array<vec4f, 9>\");\n        this.createUniform(\"kernels\", \"array<mat4x4f, 9>\");\n        this.createUniform(\"bias\", \"vec4f\");\n        // Set up pipeline in Lazy Load\n        this.setUniform(\"kernel_offsets\", new Float32Array([\n            -1, -1, 0, 0,\n            -1, 0, 0, 0,\n            -1, 1, 0, 0,\n            0, -1, 0, 0,\n            0, 0, 0, 0,\n            0, 1, 0, 0,\n            1, -1, 0, 0,\n            1, 0, 0, 0,\n            1, 1, 0, 0,\n        ]));\n        this.setUniform(\"kernels\", new Float32Array(kernels));\n        this.setUniform(\"bias\", new Float32Array(bias));\n    }\n    lazyLoadSetup() {\n        const externalTexture = this.inputs[0] instanceof GPUExternalTexture;\n        const textureLoad = externalTexture ? 'textureLoad(inputTexture0, coord + offset)' :\n            'textureLoad(inputTexture0, coord + offset, 0)';\n        this.shader = this.createStandardShader(`\n        \n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\n          \n                let x = id.x;\n                let y = id.y;\n                \n                let i = id.y*${this.resolution.width} + x;\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\n                \n                let coord = vec2<i32>( i32(x), i32(y));\n                      \n                 for(var i = 0u; i < 9; i++){\n                   let offset = vec2<i32>(kernel_offsets[i].xy);\n                   result += kernels[i]*${textureLoad};\n                 } \n                    \n                result += bias;\n                \n                outputBuffer[i] = result;\n          }\n        `);\n        this.pipeline = this.device.createComputePipeline(this.defaultPipelineConfig());\n        this.bindGroup = this.defaultBindGroup();\n    }\n}\nexports[\"default\"] = Anime4KConv3x4;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-3x4.ts?");

/***/ }),

/***/ "./src/layers/anime4k/conv2d-8x4.ts":
/*!******************************************!*\
  !*** ./src/layers/anime4k/conv2d-8x4.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_compute_layer_1 = __webpack_require__(/*! ../base_compute_layer */ \"./src/layers/base_compute_layer.ts\");\nclass Anime4KConv8x4 extends base_compute_layer_1.default {\n    constructor(inputs, outputBuffer, weights) {\n        super(inputs, outputBuffer, weights);\n        this.label = \"Anime4KConv8x4\";\n        const kernels = weights.weights;\n        const bias = weights.bias;\n        this.createUniform(\"kernel_offsets\", \"array<vec4f, 9>\");\n        this.createUniform(\"kernels\", \"array<mat4x4f, 18>\");\n        this.createUniform(\"bias\", \"vec4f\");\n        this.shader = this.createStandardShader(`\n        \n          @compute @workgroup_size(${this.num_work_groups}, ${this.num_work_groups}) fn main( @builtin(global_invocation_id) id: vec3<u32>) {\n          \n                let x = id.x;\n                let y = id.y;\n                \n                let i = id.y*${this.resolution.width} + x;\n                var result  = vec4f(0.0, 0.0, 0.0, 0.0);\n                \n                let coord = vec2<i32>( i32(x), i32(y));\n                      \n                 for(var i = 0u; i < 9; i++){\n                   let pixel_loc = coord + vec2<i32>(kernel_offsets[i].xy);\n                   let buff_ind = pixel_loc.y*${this.resolution.width} + pixel_loc.x;\n                   \n                   let pix_val = inputBuffer0[buff_ind];\n                  \n                   result += kernels[i]*max(pix_val, vec4f(0.0));\n                   result += kernels[i+9]*max(-1.0*pix_val, vec4f(0.0));\n                 } \n                    \n                result += bias;\n                \n                outputBuffer[i] = result;\n          }\n        `);\n        this.setUniform(\"kernel_offsets\", new Float32Array([\n            -1, -1, 0, 0,\n            -1, 0, 0, 0,\n            -1, 1, 0, 0,\n            0, -1, 0, 0,\n            0, 0, 0, 0,\n            0, 1, 0, 0,\n            1, -1, 0, 0,\n            1, 0, 0, 0,\n            1, 1, 0, 0,\n        ]));\n        this.setUniform(\"kernels\", new Float32Array(kernels));\n        this.setUniform(\"bias\", new Float32Array(bias));\n        this.defaultSetup();\n    }\n}\nexports[\"default\"] = Anime4KConv8x4;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/conv2d-8x4.ts?");

/***/ }),

/***/ "./src/layers/anime4k/display.ts":
/*!***************************************!*\
  !*** ./src/layers/anime4k/display.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \"./src/layers/base_render_layer.ts\");\nclass DisplayLayer extends base_render_layer_1.default {\n    constructor(inputs, output) {\n        super(inputs, output);\n        this.label = \"DisplayLayer\";\n        this.vertexScale = {\n            width: 1,\n            height: 1\n        };\n        this.sampler = this.device.createSampler({\n            addressModeU: \"repeat\",\n            addressModeV: \"repeat\",\n            magFilter: \"linear\",\n            minFilter: \"linear\",\n            mipmapFilter: \"linear\",\n        });\n    }\n    lazyLoadSetup() {\n        const externalTexture = this.inputs[1] instanceof GPUExternalTexture;\n        const textureLoad = externalTexture ? 'textureSampleBaseClampToEdge(inputTexture, ourSampler, input.tex_coord)' :\n            'textureSample(inputTexture, ourSampler, input.tex_coord)';\n        this.shader = this.device.createShaderModule({\n            label: `${this.label}-shader`,\n            code: `\n                \n                   ${this.defaultVertexShader()}\n                   @group(0) @binding(0) var<storage, read_write> inputBuffer0: array<vec4f>;\n                   @group(0) @binding(1) var inputTexture: ${externalTexture ? 'texture_external' : 'texture_2d<f32>'};\n                   @group(0) @binding(2) var ourSampler: sampler;\n                  \n                   @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n                      \n                        let x = ${this.resolution.width}.0*(input.tex_coord.x);\n                        let y = ${this.resolution.height}.0*(input.tex_coord.y);\n                        \n                        let y2 = u32(floor(y));\n                        let x2 = u32(floor(x));\n                        \n                        let i = y2*${Math.floor(this.resolution.width)} +  x2;\n                       \n                        let x_floor  = u32(fract(x)*2.0);\n                        let y_floor  = u32(fract(y)*2.0);\n                        \n                        //I don t know, I think this is right? I found this by trial and error\n                        let c_index: u32 = x_floor + y_floor*2;  \n        \n                        let value = inputBuffer0[i][c_index];\n                        \n                        let bicubic = ${textureLoad};\n                        \n                        return bicubic + vec4f(value);\n                    \n                      }            \n            `\n        });\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\n        this.bindGroup = this.defaultBindGroup();\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\n    }\n    defaultBindGroup() {\n        const entries = [];\n        this.inputs.forEach(function (input, i) {\n            if (input instanceof GPUExternalTexture) {\n                entries.push({ binding: i, resource: input });\n            }\n            else if (input instanceof GPUTexture) {\n                entries.push({ binding: i, resource: input.createView() });\n            }\n            else if (input instanceof GPUBuffer) {\n                entries.push({ binding: i, resource: { buffer: input } });\n            }\n        });\n        entries.push({ binding: this.inputs.length, resource: this.sampler });\n        return this.device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(0),\n            entries\n        });\n    }\n    setOutput(outputTexture) {\n        this.output = outputTexture;\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\n    }\n}\nexports[\"default\"] = DisplayLayer;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/anime4k/display.ts?");

/***/ }),

/***/ "./src/layers/base_compute_layer.ts":
/*!******************************************!*\
  !*** ./src/layers/base_compute_layer.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_layer_1 = __webpack_require__(/*! ./base_layer */ \"./src/layers/base_layer.ts\");\nclass ComputeLayer extends base_layer_1.default {\n    constructor(inputTextures, outputBuffer, weights) {\n        super(inputTextures, outputBuffer, weights);\n        this.num_work_groups = 8;\n    }\n    createStandardShader(computeShader) {\n        return this.device.createShaderModule({\n            label: `${this.label}-shader`,\n            code: `\n              \n              ${this.computeShaderInputs()}\n              \n              ${computeShader}\n        `\n        });\n    }\n    computeShaderInputs() {\n        const inputs = [];\n        for (let i = 0; i < this.inputs.length; i++) {\n            if (this.inputs[i] instanceof GPUTexture) {\n                inputs.push(`@group(0) @binding(${i}) var inputTexture${i}: texture_2d<f32>;`);\n            }\n            else if (this.inputs[i] instanceof GPUExternalTexture) {\n                inputs.push(`@group(0) @binding(${i}) var inputTexture${i}: texture_external;`);\n            }\n            else if (this.inputs[i] instanceof GPUBuffer) {\n                inputs.push(`@group(0) @binding(${i}) var<storage, read_write> inputBuffer${i}: array<vec4f>;`);\n            }\n            else {\n                throw new Error(\"Input is undefined or non of the correct input type\");\n            }\n        }\n        this.uniforms.forEach((uniform, i) => {\n            inputs.push(`@group(0) @binding(${i + this.inputs.length}) var <uniform> ${uniform.name}: ${uniform.type};`);\n        });\n        inputs.push(`@group(0) @binding(${this.inputs.length + this.uniforms.length}) var <storage, read_write> outputBuffer: array<vec4f>;`);\n        return inputs.join('\\n');\n    }\n    defaultPipelineConfig() {\n        return {\n            label: `${this.label}-pipeline`,\n            layout: 'auto',\n            compute: {\n                module: this.shader,\n                entryPoint: 'main',\n            },\n        };\n    }\n    defaultSetup() {\n        this.pipeline = this.device.createComputePipeline(this.defaultPipelineConfig());\n        this.bindGroup = this.defaultBindGroup();\n    }\n    lazyLoadSetup() {\n    }\n    run() {\n        const encoder = this.device.createCommandEncoder({ label: this.label });\n        if (!this.pipeline)\n            this.lazyLoadSetup();\n        const pass = encoder.beginComputePass({ label: this.label });\n        pass.setPipeline(this.pipeline);\n        if (this.hasExternalTexture()) {\n            this.bindGroup = this.defaultBindGroup();\n        }\n        if (this.bindGroup) {\n            pass.setBindGroup(0, this.bindGroup);\n        }\n        // Dividing into work groups speeds up inference. If width or height aren't cleandly divided by work groups, we round to the nearest multiple of work-groups\n        // Physically, this means shaving a few pixels (up to num_work_groups-1) off the bottom and right edges of the canvas but users shouldn't notice?\n        pass.dispatchWorkgroups(Math.floor(this.resolution.width / this.num_work_groups), Math.floor(this.resolution.height / this.num_work_groups));\n        pass.end();\n        this.device.queue.submit([encoder.finish()]);\n    }\n}\nexports[\"default\"] = ComputeLayer;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/base_compute_layer.ts?");

/***/ }),

/***/ "./src/layers/base_layer.ts":
/*!**********************************!*\
  !*** ./src/layers/base_layer.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Layer {\n    constructor(inputs, output, weights) {\n        this.context = globalThis.context;\n        this.device = this.context.device;\n        this.resolution = this.context.resolution;\n        this.inputs = inputs;\n        this.output = output;\n        this.uniforms = [];\n        this.buffers = {};\n        this.weights = weights;\n    }\n    createUniform(name, type) {\n        this.uniforms.push({ name, type });\n    }\n    setUniform(name, value) {\n        const buffer = this.device.createBuffer({\n            label: `layer-${this.label}-buffer-${name}`,\n            size: value.byteLength,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n        this.device.queue.writeBuffer(buffer, /*bufferOffset=*/ 0, value);\n        this.buffers[name] = buffer;\n    }\n    defaultBindGroup() {\n        const entries = [];\n        this.inputs.forEach(function (input, i) {\n            if (input instanceof GPUExternalTexture) {\n                entries.push({ binding: i, resource: input });\n            }\n            else if (input instanceof GPUTexture) {\n                entries.push({ binding: i, resource: input.createView() });\n            }\n            else if (input instanceof GPUBuffer) {\n                entries.push({ binding: i, resource: { buffer: input } });\n            }\n        });\n        this.uniforms.forEach((uniform, i) => {\n            entries.push({\n                binding: i + this.inputs.length,\n                resource: {\n                    buffer: this.buffers[uniform.name]\n                }\n            });\n        });\n        if (this.output instanceof GPUBuffer) {\n            entries.push({\n                binding: this.inputs.length + this.uniforms.length,\n                resource: {\n                    buffer: this.output\n                }\n            });\n        }\n        if (entries.length === 0)\n            return null;\n        return this.device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(0),\n            entries\n        });\n    }\n    hasExternalTexture() {\n        for (const input of this.inputs) {\n            if (input instanceof GPUExternalTexture)\n                return true;\n        }\n        return false;\n    }\n    lazyLoadSetup() { }\n    run() { }\n}\nexports[\"default\"] = Layer;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/base_layer.ts?");

/***/ }),

/***/ "./src/layers/base_render_layer.ts":
/*!*****************************************!*\
  !*** ./src/layers/base_render_layer.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_layer_1 = __webpack_require__(/*! ./base_layer */ \"./src/layers/base_layer.ts\");\nclass RenderLayer extends base_layer_1.default {\n    constructor(inputs, output, weights) {\n        super(inputs, output, weights);\n        this.vertexScale = this.context.resolution;\n    }\n    defaultVertexShader() {\n        return `\n        \n             struct VertexShaderOutput {\n                @builtin(position) position: vec4f,\n                @location(0) tex_coord: vec2f,\n              };\n\n            @vertex\n            fn vertexMain( @builtin(vertex_index) vertexIndex : u32) ->  VertexShaderOutput{\n                let pos = array(\n                // 1st triangle\n                vec2f( -1.0,  -1.0),  // center\n                vec2f( 1.0,  -1.0),  // right, center\n                vec2f( -1.0,  1.0),  // center, top\n             \n                // 2st triangle\n                vec2f( -1.0,  1.0),  // center, top\n                vec2f( 1.0,  -1.0),  // right, center\n                vec2f( 1.0,  1.0),  // right, top\n              );\n             \n              var vsOutput: VertexShaderOutput;\n              let xy = pos[vertexIndex];\n              vsOutput.position = vec4f(xy, 0.0, 1.0);\n              vsOutput.tex_coord = xy*0.5 + 0.5;\n              vsOutput.tex_coord.y = - 1.0* vsOutput.tex_coord.y  + 1.0;\n               vsOutput.tex_coord.x =  vsOutput.tex_coord.x*${this.vertexScale.width};\n               vsOutput.tex_coord.y =  vsOutput.tex_coord.y*${this.vertexScale.height};\n              return vsOutput;\n            }\n        `;\n    }\n    defaultPipelineConfig() {\n        return {\n            label: `${this.label}-pipeline`,\n            layout: 'auto',\n            vertex: {\n                module: this.shader,\n                entryPoint: 'vertexMain',\n            },\n            fragment: {\n                module: this.shader,\n                entryPoint: 'fragmentMain',\n                targets: [{ format: this.output.format }],\n            },\n        };\n    }\n    defaultSetup() {\n        this.pipeline = this.device.createRenderPipeline(this.defaultPipelineConfig());\n        this.bindGroup = this.defaultBindGroup();\n        this.renderPassDescriptor = this.defaultRenderPassDescriptor();\n    }\n    defaultRenderPassDescriptor() {\n        return {\n            label: `${this.label}-render-pass`,\n            colorAttachments: [\n                {\n                    view: this.output.createView(),\n                    clearValue: [0, 0, 0, 1],\n                    loadOp: 'clear',\n                    storeOp: 'store',\n                },\n            ],\n        };\n    }\n    createStandardShader(fragmentShader) {\n        return this.device.createShaderModule({\n            label: `${this.label}-shader`,\n            code: `\n          \n              ${this.defaultVertexShader()}\n              \n              ${this.fragmentShaderInputs()}\n              \n              ${fragmentShader}\n        `\n        });\n    }\n    fragmentShaderInputs() {\n        const inputs = [];\n        for (let i = 0; i < this.inputs.length; i++) {\n            let type = (this.inputs[i] instanceof GPUTexture) ? 'texture_2d<f32>' : 'texture_external';\n            inputs.push(`@group(0) @binding(0) var inputTexture${i}: ${type};`);\n        }\n        this.uniforms.forEach((uniform, i) => {\n            inputs.push(`@group(0) @binding(${i + this.inputs.length}) var <uniform> ${uniform.name}: ${uniform.type};`);\n        });\n        return inputs.join('\\n');\n    }\n    run() {\n        const encoder = this.device.createCommandEncoder({ label: this.label });\n        if (!this.pipeline)\n            this.lazyLoadSetup();\n        const pass = encoder.beginRenderPass(this.renderPassDescriptor);\n        pass.setPipeline(this.pipeline);\n        if (this.hasExternalTexture()) {\n            this.bindGroup = this.defaultBindGroup();\n        }\n        if (this.bindGroup) {\n            pass.setBindGroup(0, this.bindGroup);\n        }\n        pass.draw(6); // call our vertex shader 6 times\n        pass.end();\n        this.device.queue.submit([encoder.finish()]);\n    }\n}\nexports[\"default\"] = RenderLayer;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/base_render_layer.ts?");

/***/ }),

/***/ "./src/layers/utils/gaussian.ts":
/*!**************************************!*\
  !*** ./src/layers/utils/gaussian.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \"./src/layers/base_render_layer.ts\");\nclass GuassianLayer extends base_render_layer_1.default {\n    constructor(inputTextures, outputTexture) {\n        super(inputTextures, outputTexture);\n        this.label = \"Gaussian\";\n        this.createUniform(\"gaussian\", \"array<vec3f, 3>\");\n        this.createUniform(\"kernel_offsets\", \"array<vec4f, 9>\");\n        this.shader = this.createStandardShader(`\n        \n                  @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n                  \n                     var val  = 0.0;\n                      \n                     for(var i = 0u; i < 3; i++){\n                     \n                        let a = vec3f(\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x,\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x,\n                            textureLoad(inputTexture0, vec2<i32>(input.tex_coord + kernel_offsets[i*3].xy), 0).x\n                        );\n                        \n                        val += dot(a, gaussian[i]);\n                      \n                    } \n                  \n                    \n                    return vec4f(val, val, val, 1.0);\n                  }                 \n        `);\n        this.setUniform(\"gaussian\", new Float32Array([\n            0.0675, 0.125, 0.0675, 0.0,\n            0.125, 0.250, 0.1250, 0.0,\n            0.0675, 0.125, 0.0675, 0.0\n        ]));\n        this.setUniform(\"kernel_offsets\", new Float32Array([\n            -1, -1, 0, 0,\n            0, -1, 0, 0,\n            1, -1, 0, 0,\n            -1, 0, 0, 0,\n            0, 0, 0, 0,\n            1, 0, 0, 0,\n            -1, 1, 0, 0,\n            0, 1, 0, 0,\n            1, 1, 0, 0,\n        ]));\n        this.defaultSetup();\n    }\n}\nexports[\"default\"] = GuassianLayer;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/utils/gaussian.ts?");

/***/ }),

/***/ "./src/layers/utils/rgb_2_yuv.ts":
/*!***************************************!*\
  !*** ./src/layers/utils/rgb_2_yuv.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_render_layer_1 = __webpack_require__(/*! ../base_render_layer */ \"./src/layers/base_render_layer.ts\");\nclass RGB2YUV extends base_render_layer_1.default {\n    constructor(inputTextures, outputTexture) {\n        super(inputTextures, outputTexture);\n        this.createUniform(\"rgb2yuv\", \"mat3x3f\");\n        this.shader = this.createStandardShader(`\n        \n               @fragment fn fragmentMain(input: VertexShaderOutput) -> @location(0) vec4f {\n              \n                    let color = textureLoad(inputTexture0, vec2<i32>(input.tex_coord), 0);       \n                    let yuv = rgb2yuv*color.xyz;\n          \n                return vec4f(yuv, 1.0);\n              }     \n        `);\n        this.setUniform(\"rgb2yuv\", new Float32Array([\n            0.299, -0.1473, 0.615, 1.0,\n            0.587, -.2886, -.51499, 1.0,\n            0.114, 0.436, -.1001, 1.0\n        ]));\n        this.defaultSetup();\n    }\n}\nexports[\"default\"] = RGB2YUV;\n\n\n//# sourceURL=webpack://WebSR/./src/layers/utils/rgb_2_yuv.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst context_1 = __webpack_require__(/*! ./context */ \"./src/context.ts\");\nconst renderer_1 = __webpack_require__(/*! ./renderer */ \"./src/renderer.ts\");\nconst network_list_1 = __webpack_require__(/*! ./networks/network_list */ \"./src/networks/network_list.ts\");\nclass WebSR {\n    constructor(params) {\n        this.source = params.source;\n        const source = this.source;\n        this.resolution = params.resolution ? params.resolution : {\n            width: (source instanceof HTMLVideoElement) ? source.videoWidth : (source instanceof HTMLImageElement) ? source.naturalWidth : source.width,\n            height: (source instanceof HTMLVideoElement) ? source.videoHeight : (source instanceof HTMLImageElement) ? source.naturalHeight : source.height\n        };\n        if (params.canvas)\n            this.canvas = params.canvas;\n        else {\n            this.canvas = new HTMLCanvasElement();\n            this.canvas.width = this.resolution.width * 2;\n            this.canvas.height = this.resolution.height * 2;\n        }\n        this.context = new context_1.default(params.gpu, this.resolution, this.canvas, this.debug);\n        globalThis.context = this.context;\n        if (!network_list_1.NetworkList[params.network_name])\n            throw Error(`Network ${params.network_name} is not defined or implemented`);\n        this.network = new network_list_1.NetworkList[params.network_name](params.weights);\n        this.renderer = new renderer_1.default(this.network, this.source);\n    }\n    static initWebGPU() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!navigator.gpu)\n                return false;\n            const adapter = yield navigator.gpu.requestAdapter();\n            if (!adapter)\n                return false;\n            const device = yield adapter.requestDevice();\n            if (!device)\n                return false;\n            return device;\n        });\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.renderer.start();\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.renderer.stop();\n        });\n    }\n    render(source) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.renderer.render(source);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.renderer.stop();\n            this.context.destroy();\n        });\n    }\n}\nexports[\"default\"] = WebSR;\n\n\n//# sourceURL=webpack://WebSR/./src/main.ts?");

/***/ }),

/***/ "./src/networks/anime4k/cnn-2x-s.ts":
/*!******************************************!*\
  !*** ./src/networks/anime4k/cnn-2x-s.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_network_1 = __webpack_require__(/*! ../base_network */ \"./src/networks/base_network.ts\");\nconst conv2d_3x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-3x4 */ \"./src/layers/anime4k/conv2d-3x4.ts\");\nconst conv2d_8x4_1 = __webpack_require__(/*! ../../layers/anime4k/conv2d-8x4 */ \"./src/layers/anime4k/conv2d-8x4.ts\");\nconst display_1 = __webpack_require__(/*! ../../layers/anime4k/display */ \"./src/layers/anime4k/display.ts\");\nclass Anime4KCNN2XS extends base_network_1.default {\n    constructor(weights) {\n        super(weights);\n    }\n    model() {\n        const layers = [];\n        const weights = this.weights.layers;\n        const context = this.context;\n        const conv2d_tf = new conv2d_3x4_1.default([context.input], context.buffer('conv2d_tf'), weights['conv2d_tf']);\n        const conv2d_1_tf = new conv2d_8x4_1.default([context.buffer('conv2d_tf')], context.buffer('conv2d_1_tf'), weights['conv2d_1_tf']);\n        const conv2d_2_tf = new conv2d_8x4_1.default([context.buffer('conv2d_1_tf')], context.buffer('conv2d_2_tf'), weights['conv2d_2_tf']);\n        const conv2d_last_tf = new conv2d_8x4_1.default([context.buffer('conv2d_2_tf')], context.buffer('conv2d_last_tf'), weights['conv2d_last_tf']);\n        const paint = new display_1.default([context.buffer('conv2d_last_tf'), context.input], context.texture('output'));\n        layers.push(conv2d_tf, conv2d_1_tf, conv2d_2_tf, conv2d_last_tf, paint);\n        return layers;\n    }\n    feedForward(source) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (source instanceof HTMLVideoElement) {\n                this.context.input = this.context.device.importExternalTexture({ source });\n            }\n            else {\n                const bitmap = source instanceof ImageBitmap ? source : yield createImageBitmap(source);\n                const width = source instanceof HTMLImageElement ? source.naturalWidth : source.width;\n                const height = source instanceof HTMLImageElement ? source.naturalHeight : source.height;\n                this.context.device.queue.copyExternalImageToTexture({ source: bitmap }, { texture: this.context.texture('input', { format: \"rgba8unorm\" }) }, [width, height]);\n                this.context.input = this.context.texture('input');\n            }\n            this.layers[0].inputs[0] = this.context.input;\n            this.layers[4].inputs[1] = this.context.input;\n            this.layers.forEach(function (layer) {\n                layer.run();\n            });\n        });\n    }\n}\nexports[\"default\"] = Anime4KCNN2XS;\n\n\n//# sourceURL=webpack://WebSR/./src/networks/anime4k/cnn-2x-s.ts?");

/***/ }),

/***/ "./src/networks/base_network.ts":
/*!**************************************!*\
  !*** ./src/networks/base_network.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass NeuralNetwork {\n    constructor(weights) {\n        this.weights = weights;\n        this.context = globalThis.context;\n        this.layers = this.model();\n    }\n    model() {\n        return [];\n    }\n    lastLayer() {\n        return this.layers[this.layers.length - 1];\n    }\n    feedForward(source) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.layers.forEach(layer => {\n                layer.run();\n            });\n        });\n    }\n}\nexports[\"default\"] = NeuralNetwork;\n\n\n//# sourceURL=webpack://WebSR/./src/networks/base_network.ts?");

/***/ }),

/***/ "./src/networks/network_list.ts":
/*!**************************************!*\
  !*** ./src/networks/network_list.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NetworkList = void 0;\nconst cnn_2x_s_1 = __webpack_require__(/*! ./anime4k/cnn-2x-s */ \"./src/networks/anime4k/cnn-2x-s.ts\");\nconst poc_network_1 = __webpack_require__(/*! ./poc_network */ \"./src/networks/poc_network.ts\");\nexports.NetworkList = {\n    \"anime4k/cnn-2x-s\": cnn_2x_s_1.default,\n    \"sb2702/blur-poc\": poc_network_1.default\n};\n\n\n//# sourceURL=webpack://WebSR/./src/networks/network_list.ts?");

/***/ }),

/***/ "./src/networks/poc_network.ts":
/*!*************************************!*\
  !*** ./src/networks/poc_network.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst base_network_1 = __webpack_require__(/*! ./base_network */ \"./src/networks/base_network.ts\");\nconst rgb_2_yuv_1 = __webpack_require__(/*! ../layers/utils/rgb_2_yuv */ \"./src/layers/utils/rgb_2_yuv.ts\");\nconst gaussian_1 = __webpack_require__(/*! ../layers/utils/gaussian */ \"./src/layers/utils/gaussian.ts\");\nclass PoCNetwork extends base_network_1.default {\n    constructor() {\n        super();\n    }\n    model() {\n        const layers = [];\n        const context = this.context;\n        layers.push(new rgb_2_yuv_1.default([context.texture('input')], context.texture('yuv')));\n        layers.push(new gaussian_1.default([context.texture('yuv')], context.texture('output')));\n        return layers;\n    }\n}\nexports[\"default\"] = PoCNetwork;\n\n\n//# sourceURL=webpack://WebSR/./src/networks/poc_network.ts?");

/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst display_1 = __webpack_require__(/*! ./layers/anime4k/display */ \"./src/layers/anime4k/display.ts\");\nclass WebSRRenderer {\n    constructor(network, source) {\n        this.context = globalThis.context;\n        this.network = network;\n        this.source = source;\n        this.active = false;\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.context.destroyed) {\n                throw new Error(\"WebSR instance was destroyed\");\n            }\n            this.active = true;\n            yield this.renderStep();\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.active = false;\n            if (this.vfc && this.source && this.source instanceof HTMLVideoElement)\n                this.source.cancelVideoFrameCallback(this.vfc);\n        });\n    }\n    renderStep() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const lastLayer = this.network.lastLayer();\n            if (lastLayer instanceof display_1.default)\n                lastLayer.setOutput(this.context.context.getCurrentTexture());\n            yield this.render();\n            if (this.active && this.source && this.source instanceof HTMLVideoElement) {\n                this.vfc = this.source.requestVideoFrameCallback(this.renderStep.bind(this));\n            }\n        });\n    }\n    render(source) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (source) {\n                const lastLayer = this.network.lastLayer();\n                if (lastLayer instanceof display_1.default)\n                    lastLayer.setOutput(this.context.context.getCurrentTexture());\n            }\n            yield this.network.feedForward(source ? source : this.source);\n            if (source)\n                yield this.context.device.queue.onSubmittedWorkDone();\n        });\n    }\n}\nexports[\"default\"] = WebSRRenderer;\n\n\n//# sourceURL=webpack://WebSR/./src/renderer.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});